# Object超类 （The Object Superclass）

+ Java里的每个类，直接或间接都是Object超类的后代。Object类提供了几种可以在子类进行扩展的方法。

## Clone

+ `clone()`方法最初设计是用来返回一个`Cloebale`接口实现的对象的副本。克隆作为浅拷贝时，这个拷贝与原始对象共享着相同的引用；作为深拷贝时，将原始的值复制到新对象中。不幸的是，正确的重载这个方法很困难，它没有提供拷贝构造函数，提供更多灵活性和*cleaner contract*。

## Equals

+ `equals()`方法比较两个对象是否相等。默认的实现依赖于恒等操作符（==）来确定两个对象指向同样的内存地址。*鼓励子类重写此方法来测试两个对象是否包含相同的信息而不是内存中的相同位置。*如果要重载`equals()`方法，必须要重载相应的`hashcode()`方法。

## HashCode

+ `HashCode()`方法将对象的状态摘要为一个整数，这个整数通常用于hash表的数据结构。默认情况下，哈希码是通过将对象的内部地址转换为整数来实现。哈希码必须始终要有返回值，对同一个对象每次的返回值要与`equals()`方法相等。

## ToString

+ `toString()`方法返回对象的表示文本，这个文本主要用于日志和调试。默认情况下，`toString()`方法返回对象的类，哈希值的十六进的表达式。

## GetClass

+ `getClass()`方法返回一个包含信息类和工具的方法，映射了领域和方法的对象。`getClass()`方法是final的并且不能由子类重载。

## Finalize

+ `finalize()`方法最早是被设计用来调用被垃圾回收集销毁的对象。然而，一个对象没有被引用，或者在垃圾回收器工作之前退出，它就没不能进入垃圾回收集中。通常不鼓励用这个方法去清理操作，由于它的不确定性和可能性，存在创建多余的引用。

## Wait,Notify,NotifyAll

+ *The final methods* `wait()`,`notify()`和`NotifyAll()`方法提供了低级别的，允许线程之间通信的并发操作。例如，一个线程可以挂起一个执行直接他收到另一个线程的通知。Java在`java.util.concurrent`包里提供了高级别的并发数据结构。

## 问题

1. 浅拷贝和深拷贝之间有什么区别？
2. 为什么说拷贝构造函数更适合克隆方法`clone()`？
3. 恒等运行符（*the identity operator*）与`equals()`方法之间有什么区别？
4. `HashCode()`方法和`Equals()`方法之间的关系是什么？
5. `toString()`方法的默认实现是什么？
6. 为什么`finalize()`方法的清理操作不可靠？

## 履历

+ 2018-03-26第一次翻译OK。
